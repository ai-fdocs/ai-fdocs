import { existsSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import chalk from "chalk";
import { resolveVersions } from "../resolver.js";
import { NpmRegistryClient, extractGithubRepo } from "../registry.js";
import { AiDocsError } from "../error.js";

const SKIP_PATTERNS: string[] = [
  "@types/",
  "tslib",
  "typescript",
  "prettier",
  "eslint",
  "@eslint/",
  "@typescript-eslint/",
  "semver",
  "lru-cache",
  "ms",
  "debug",
];

function shouldSkip(name: string): boolean {
  return SKIP_PATTERNS.some((pattern) => (pattern.endsWith("/") ? name.startsWith(pattern) : name === pattern));
}

export async function cmdInit(projectRoot: string, overwrite: boolean): Promise<void> {
  const configPath = join(projectRoot, "ai-fdocs.toml");
  if (existsSync(configPath) && !overwrite) {
    throw new AiDocsError("ai-fdocs.toml already exists. Use --overwrite to replace.", "UNKNOWN");
  }

  console.log(chalk.blue("Scanning lockfile..."));
  const lockVersions = resolveVersions(projectRoot);
  console.log(chalk.green(`Found ${lockVersions.size} packages in lockfile.`));

  const candidates = [...lockVersions.keys()].filter((name) => !shouldSkip(name)).sort();
  console.log(chalk.gray(`${candidates.length} candidates after filtering.`));

  const registry = new NpmRegistryClient();
  const resolved = new Map<string, { repo: string; subpath?: string; description?: string }>();

  let skippedNoRepo = 0;
  let skippedNotGithub = 0;

  for (let i = 0; i < candidates.length; i++) {
    const name = candidates[i];
    if (i > 0 && i % 30 === 0) {
      console.log(chalk.gray(`  Progress: ${i}/${candidates.length} packages queried...`));
    }

    const info = await registry.getPackageInfo(name);
    if (!info?.repository) {
      skippedNoRepo++;
      continue;
    }

    const extracted = extractGithubRepo(info.repository);
    if (!extracted) {
      skippedNotGithub++;
      continue;
    }

    const subpath = extracted.subpath ?? (await getRepositoryDirectory(name));
    resolved.set(name, { repo: extracted.repo, subpath, description: info.description ?? undefined });

    if (i % 10 === 0) await sleep(50);
  }

  console.log(chalk.green(`Resolved ${resolved.size} packages (${skippedNoRepo} no repo, ${skippedNotGithub} non-GitHub).`));

  let toml = "";
  toml += "# Generated by `ai-fdocs init`\n";
  toml += "[settings]\n";
  toml += 'output_dir = "docs/ai/vendor-docs/node"\n';
  toml += "prune = true\n";
  toml += "max_file_size_kb = 512\n\n";

  for (const [name, info] of resolved) {
    const key = needsQuoting(name) ? `"${name}"` : name;
    toml += `[packages.${key}]\n`;
    toml += `repo = "${info.repo}"\n`;
    if (info.subpath) toml += `subpath = "${info.subpath}"\n`;
    if (info.description) toml += `# ${info.description.slice(0, 100)}\n`;
    toml += "\n";
  }

  writeFileSync(configPath, toml, "utf-8");
  console.log(chalk.green(`\nâœ… Generated ai-fdocs.toml with ${resolved.size} packages.`));
}

async function getRepositoryDirectory(name: string): Promise<string | undefined> {
  try {
    const encodedName = name.replace("/", "%2F");
    const resp = await fetch(`https://registry.npmjs.org/${encodedName}/latest`);
    if (!resp.ok) return undefined;

    const data = (await resp.json()) as { repository?: { directory?: string } | string };
    if (data.repository && typeof data.repository === "object" && typeof data.repository.directory === "string") {
      return data.repository.directory;
    }

    return undefined;
  } catch {
    return undefined;
  }
}

function needsQuoting(key: string): boolean {
  return key.includes("@") || key.includes("/") || key.includes("-") || key.includes(".");
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
